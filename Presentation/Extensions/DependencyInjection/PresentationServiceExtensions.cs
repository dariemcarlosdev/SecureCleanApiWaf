using Microsoft.OpenApi.Models;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using AspNetCoreRateLimit;

namespace SecureCleanApiWaf.Presentation.Extensions.DependencyInjection
{
    /// <summary>
    /// Dependency injection setup for Presentation layer services
    /// Registers Blazor, API controllers, Swagger, and web-specific services
    /// </summary>
    /// <remarks>
    /// This extension method configures all Presentation layer dependencies:
    /// - JWT Bearer Authentication
    /// - Authorization Policies
    /// - Rate Limiting
    /// - CORS (Cross-Origin Resource Sharing)
    /// - Blazor Server
    /// - API Controllers
    /// - Swagger/OpenAPI Documentation
    /// - Health Checks
    /// 
    /// Called from Program.cs during application startup:
    /// builder.Services.AddPresentationServices(builder.Configuration);
    /// 
    /// Configuration sources:
    /// - appsettings.json (base configuration)
    /// - appsettings.{Environment}.json (environment-specific)
    /// - Azure Key Vault (production secrets)
    /// - Environment variables (overrides)
    /// </remarks>
    public static class PresentationServiceExtensions
    {
        /// <summary>
        /// Registers and configures presentation-layer services into the dependency injection container, including ProblemDetails, JWT authentication, authorization policies, rate limiting, CORS, Blazor server components, API controllers, Swagger/OpenAPI, and health checks.
        /// </summary>
        /// <returns>The same <see cref="IServiceCollection"/> instance with presentation services registered.</returns>
        public static IServiceCollection AddPresentationServices(this IServiceCollection services, IConfiguration configuration)
        {
            // ===========================================================================================
            // PROBLEM DETAILS CONFIGURATION (ADD THIS FIRST)
            // ===========================================================================================
            // Problem Details Schema is autogenerated by ASP.NET Core for error responses and follows RFC 7807 standard industry standard.
            // It is part of the Microsoft.AspNetCore.Mvc.ProblemDetails package. and provides a consistent format for error responses across the API with additional custom properties for better diagnostics.
            // ProblemDetails middleware intercepts exceptions and converts them into standardized error responses.
            // Returns JSON with fields like type, title, status, detail, instance, plus custom extensions part of ProblemDetails response body.
            //Return ProblemDetails for unhandled exceptions and validation errors automatically.Include all 4xx and 5xx errors.(400, 401, 403, 404, 500, etc.)
            // Configure custom ProblemDetails responses for all API errors
            // This is a custome implementation of the ProblemDetails middleware where I added additional properties to the standard RFC 7807 ProblemDetails format
            services.AddProblemDetails(options =>
            {
                // CustomizeProblemDetails: Customize every ProblemDetails response
                // This is called for ALL error responses (400, 401, 403, 404, 500, etc.)
                options.CustomizeProblemDetails = ctx =>
                {
                    // Add timestamp to track when the error occurred
                    // Useful for correlating errors with logs
                    ctx.ProblemDetails.Extensions.Add("timestamp", DateTime.UtcNow);
                    
                    // Add traceId for distributed tracing and log correlation
                    // This matches the traceId in your application logs
                    ctx.ProblemDetails.Extensions.Add("traceId", ctx.HttpContext.TraceIdentifier);
                    
                    // Add machine/server name (helpful for load-balanced environments)
                    // In production with multiple servers, shows which server handled the request
                    ctx.ProblemDetails.Extensions.Add("machineName", Environment.MachineName);
                    
                    // Add environment name (Development, Staging, Production)
                    // Helps identify which environment the error occurred in
                    var environment = ctx.HttpContext.RequestServices
                        .GetRequiredService<IWebHostEnvironment>();
                    ctx.ProblemDetails.Extensions.Add("environment", environment.EnvironmentName);
                    
                    // Add API version (useful for tracking issues in specific versions)
                    ctx.ProblemDetails.Extensions.Add("apiVersion", "v1");
                    
                    // Add request path to identify which endpoint caused the error
                    ctx.ProblemDetails.Extensions.Add("path", ctx.HttpContext.Request.Path.Value);
                    
                    // Add HTTP method to see if it's GET, POST, PUT, DELETE, etc.
                    ctx.ProblemDetails.Extensions.Add("method", ctx.HttpContext.Request.Method);
                    
                    // Optional: Add user information for authenticated requests
                    // Only add if user is authenticated (avoid null reference)
                    if (ctx.HttpContext.User?.Identity?.IsAuthenticated == true)
                    {
                        ctx.ProblemDetails.Extensions.Add("userId", 
                            ctx.HttpContext.User.Identity.Name ?? "Unknown");
                    }

                    // Optional: Customize title based on status code.
                    // Provide more user-friendly error titles for common errors.
                    ctx.ProblemDetails.Title = ctx.ProblemDetails.Status switch
                    {
                        400 => "Bad Request - Invalid Input",
                        401 => "Unauthorized - Authentication Required",
                        403 => "Forbidden - Insufficient Permissions",
                        404 => "Not Found - Resource Does Not Exist",
                        429 => "Too Many Requests - Rate Limit Exceeded",
                        500 => "Internal Server Error - Something Went Wrong",
                        _ => ctx.ProblemDetails.Title // Keep default for other status codes
                    };
                    
                    // Optional: Add support contact information
                    ctx.ProblemDetails.Extensions.Add("supportContact", "softevolutionsl@gmail.com");
                    
                    // Optional: Add documentation link
                    ctx.ProblemDetails.Extensions.Add("documentationUrl", 
                        "https://github.com/dariemcarlosdev/BlueTreadApp/wiki");
                };
            });

            // ===========================================================================================
            // JWT BEARER AUTHENTICATION CONFIGURATION
            // ===========================================================================================
            // Configures token-based authentication for API endpoints
            // Stateless authentication (no server-side session storage)
            // Tokens contain user identity and claims
            
            // ===== Load JWT Settings from Configuration =====
            // Read from appsettings.json under "JwtSettings" section
            var jwtSettings = configuration.GetSection("JwtSettings");
            
            // Secret Key: Used to sign and verify tokens (HMAC-SHA256)
            // CRITICAL: Must be at least 32 characters for security
            // Production: Store in Azure Key Vault, never in source control
            var secretKey = jwtSettings["SecretKey"] ?? throw new InvalidOperationException("JWT SecretKey is not configured");
            
            // ===== Configure Authentication Scheme =====
            // Register JWT Bearer as the default authentication method
            services.AddAuthentication(options =>
            {
                // Default scheme for authenticating users
                // When [Authorize] is used, this scheme validates the request
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                
                // Default scheme for challenging unauthorized requests
                // Returns 401 Unauthorized with WWW-Authenticate header
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            })
            // ===== Configure JWT Bearer Options =====
            .AddJwtBearer(options =>
            {
                // ===== Security: HTTPS Requirement =====
                // Enforce HTTPS metadata endpoint (for production)
                // Development: Can be false for local HTTP testing
                // Production: MUST be true to prevent token theft
                options.RequireHttpsMetadata = true;
                
                // ===== Token Storage =====
                // Save validated token in AuthenticationProperties
                // Allows accessing token later via HttpContext.GetTokenAsync()
                // Useful for passing token to downstream services
                options.SaveToken = true;
                
                // ===== Token Validation Parameters =====
                // Defines rules for validating incoming JWT tokens
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    // ===== Issuer Validation =====
                    // Verify token was created by trusted issuer (your application)
                    // Prevents tokens from other applications being accepted
                    ValidateIssuer = true,
                    ValidIssuer = jwtSettings["Issuer"], // From appsettings.json (e.g., "BlueTreadApp")
                    
                    // ===== Audience Validation =====
                    // Verify token is intended for this API
                    // Prevents tokens meant for other APIs being used here
                    ValidateAudience = true,
                    ValidAudience = jwtSettings["Audience"], // From appsettings.json (e.g., "BlueTreadApp.Api")
                    
                    // ===== Lifetime Validation =====
                    // Verify token hasn't expired
                    // Checks 'exp' (expiration) claim in token
                    ValidateLifetime = true,
                    
                    // ===== Signature Validation =====
                    // Verify token signature using secret key
                    // Ensures token hasn't been tampered with
                    // Most critical validation (prevents forged tokens)
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)),
                    
                    // ===== Clock Skew =====
                    // Remove default 5-minute tolerance for token expiration
                    // TimeSpan.Zero: Strict expiration (no grace period)
                    // Default: 5 minutes (allows for clock differences between servers)
                    // 
                    // Why remove it?
                    // - More secure (tokens expire exactly when specified)
                    // - Simpler testing (no confusion about "expired" tokens still working)
                    // 
                    // When to keep default?
                    // - Distributed systems with potential clock drift
                    // - Mobile apps with unreliable device clocks
                    ClockSkew = TimeSpan.Zero
                };
            });

            // ===========================================================================================
            // AUTHORIZATION CUSTOM POLICIES CONFIGURATION
            // ===========================================================================================
            // Defines rules for what authenticated users can do
            // Policies are more flexible than simple role checks

            services.AddAuthorization(options =>
            {
                // ===== Policy: ApiUser =====
                // Simplest policy: just requires authentication
                // No specific roles or claims needed
                // 
                // Use case: Endpoints that any authenticated user can access
                // Usage: [Authorize(Policy = "ApiUser")]
                // 
                // Equivalent to: [Authorize] (without policy)
                options.AddPolicy("ApiUser", policy => 
                    policy.RequireAuthenticatedUser());
                
                // ===== Policy: AdminOnly =====
                // Requires user to have "Admin" role claim
                // More restrictive than ApiUser
                // 
                // Use case: Administrative endpoints
                // Usage: [Authorize(Policy = "AdminOnly")]
                // 
                // How roles work:
                // 1. JWT token contains role claims (set during token generation)
                // 2. ClaimTypes.Role: Standard claim type for roles
                // 3. Policy checks if user has "Admin" in their role claims
                // 4. If yes: Allow access
                // 5. If no: Return 403 Forbidden
                // 
                // Admin users should also have "User" role (for accessing user endpoints)
                options.AddPolicy("AdminOnly", policy => 
                    policy.RequireRole("Admin"));
                
                // ===== Future Policies (Examples) =====
                // Custom policies can combine multiple requirements:
                // 
                // options.AddPolicy("ManagerOrAdmin", policy => 
                //     policy.RequireRole("Manager", "Admin")); // Either role
                // 
                // options.AddPolicy("SeniorEmployee", policy => 
                //     policy.RequireClaim("EmployeeLevel", "Senior", "Lead")); // Specific claim values
                // 
                // options.AddPolicy("MustBeOver18", policy => 
                //     policy.Requirements.Add(new MinimumAgeRequirement(18))); // Custom requirement
            });

            // ===========================================================================================
            // RATE LIMITING CONFIGURATION
            // ===========================================================================================
            // IP-based request throttling to prevent abuse
            // Uses AspNetCoreRateLimit library
            
            // ===== Memory Cache for Rate Limit Tracking =====
            // Stores request counts per IP address in memory
            // Fast lookups for rate limit decisions
            services.AddMemoryCache();
            
            // ===== Load Rate Limit Options from Configuration =====
            // Reads settings from appsettings.json "IpRateLimiting" section
            // Configuration includes:
            // - Endpoint-specific rules
            // - Time periods (per minute, per hour)
            // - Request limits
            // - HTTP status code for violations (429)
            services.Configure<IpRateLimitOptions>(configuration.GetSection("IpRateLimiting"));
            
            // ===== In-Memory Rate Limiting Store =====
            // Stores rate limit counters in application memory
            // Development: Simple, no external dependencies
            // Production: Consider distributed cache (Redis) for multiple servers
            services.AddInMemoryRateLimiting();
            
            // ===== Rate Limit Configuration Service =====
            // Manages rate limit rules and policies
            // Singleton: One instance for application lifetime
            services.AddSingleton<IRateLimitConfiguration, RateLimitConfiguration>();

            // ===========================================================================================
            // CORS (CROSS-ORIGIN RESOURCE SHARING) CONFIGURATION
            // ===========================================================================================
            // Controls which web domains can call your API
            // Browser security feature (not enforced by non-browser clients)
            
            services.AddCors(options =>
            {
                // ===== Define CORS Policy: "AllowSpecificOrigins" =====
                options.AddPolicy("AllowSpecificOrigins", builder =>
                {
                    // ===== Load Allowed Origins from Configuration =====
                    // Read from appsettings.json "Cors:AllowedOrigins" section
                    // Falls back to localhost if not configured
                    var allowedOrigins = configuration.GetSection("Cors:AllowedOrigins").Get<string[]>() 
                        ?? new[] { "https://localhost:7000" };
                    
                    // ===== CORS Policy Settings =====
                    
                    // WithOrigins: Whitelist of allowed domains
                    // Only these domains can make requests to your API
                    // Browser enforces this (sends preflight OPTIONS request)
                    builder.WithOrigins(allowedOrigins)
                    
                           // AllowAnyMethod: Allow all HTTP methods (GET, POST, PUT, DELETE, etc.)
                           // Alternative: Restrict to specific methods
                           // .WithMethods("GET", "POST")
                           .AllowAnyMethod()
                           
                           // AllowAnyHeader: Allow all request headers
                           // Alternative: Restrict to specific headers
                           // .WithHeaders("Authorization", "Content-Type")
                           .AllowAnyHeader()
                           
                           // AllowCredentials: Allow cookies and authentication headers
                           // Required for sending Authorization header with JWT tokens
                           // Note: Cannot use AllowAnyOrigin() with AllowCredentials()
                           .AllowCredentials();
                    
                    // ===== CORS Flow (Browser) =====
                    // 1. Browser sends preflight request: OPTIONS /api/v1/sample
                    //    - Origin: https://localhost:7000
                    //    - Access-Control-Request-Method: GET
                    // 2. Server checks if origin is in allowedOrigins
                    // 3. Server responds with CORS headers:
                    //    - Access-Control-Allow-Origin: https://localhost:7000
                    //    - Access-Control-Allow-Methods: GET, POST, PUT, DELETE, ...
                    //    - Access-Control-Allow-Headers: Authorization, Content-Type, ...
                    // 4. If approved, browser sends actual request
                    // 5. If rejected, browser blocks request (CORS error)
                });
            });
            
            // ===========================================================================================
            // BLAZOR SERVER CONFIGURATION
            // ===========================================================================================
            // Registers Blazor components with SignalR for real-time updates
            
            services.AddRazorComponents()
                // Enable Interactive Server rendering mode
                // Uses SignalR WebSocket connection for real-time UI updates
                // Benefits:
                // - Rich interactivity without JavaScript
                // - Server-side rendering (better SEO)
                // - Small payload (only UI diffs sent over WebSocket)
                .AddInteractiveServerComponents();
            
            // ===========================================================================================
            // API CONTROLLERS CONFIGURATION
            // ===========================================================================================
            // Registers MVC controllers for REST API endpoints
            
            services.AddControllers();
            
            // ===========================================================================================
            // SWAGGER/OPENAPI CONFIGURATION
            // ===========================================================================================
            // Interactive API documentation and testing UI
            
            // ===== API Explorer =====
            // Discovers API endpoints for Swagger generation
            services.AddEndpointsApiExplorer();
            
            // ===== Swagger Generator =====
            services.AddSwaggerGen(options =>
            {
                // ===== API Metadata =====
                // Basic information displayed in Swagger UI
                options.SwaggerDoc("v1", new OpenApiInfo
                {
                    Version = "v1",
                    Title = "BlueTread API",
                    Description = "REST API for BlueTreadApp - Clean Architecture Demo with JWT Security",
                    Contact = new OpenApiContact
                    {
                        Name = "Development Team",
                        Email = "softevolutionsl@gmail.com"
                    }
                });
                
                // ===== JWT BEARER AUTHENTICATION IN SWAGGER =====
                // Adds "Authorize" button to Swagger UI for JWT token input
                
                // Define security scheme (how authentication works)
                options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
                {
                    Name = "Authorization", // HTTP header name
                    Type = SecuritySchemeType.Http, // HTTP authentication
                    Scheme = "Bearer", // Bearer token scheme
                    BearerFormat = "JWT", // Token format
                    In = ParameterLocation.Header, // Token in header
                    
                    // Instructions displayed in Swagger UI
                    Description = "Enter 'Bearer' [space] and then your valid JWT token.\n\nExample: \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\""
                });

                // Apply security requirement to all endpoints
                // Adds lock icon to endpoints in Swagger UI
                // When clicked, prompts for JWT token
                options.AddSecurityRequirement(new OpenApiSecurityRequirement
                {
                    {
                        new OpenApiSecurityScheme
                        {
                            Reference = new OpenApiReference
                            {
                                Type = ReferenceType.SecurityScheme,
                                Id = "Bearer" // References security definition above
                            }
                        },
                        Array.Empty<string>() // No specific scopes required
                    }
                });
                
                // ===== XML COMMENTS INTEGRATION =====
                // Include XML documentation comments in Swagger UI
                // Shows /// <summary>, /// <remarks>, etc. in API docs
                // 
                // Requires: <GenerateDocumentationFile>true</GenerateDocumentationFile> in .csproj
                var xmlFile = $"{System.Reflection.Assembly.GetExecutingAssembly().GetName().Name}.xml";
                var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
                if (File.Exists(xmlPath))
                {
                    options.IncludeXmlComments(xmlPath);
                }
            });
            
            // ===========================================================================================
            // HEALTH CHECKS CONFIGURATION
            // ===========================================================================================
            // Simple health check endpoint for monitoring
            // Endpoint: /health
            // Returns: 200 OK if application is healthy
            // 
            // Use cases:
            // - Load balancer health probes
            // - Kubernetes liveness/readiness probes
            // - Azure Monitor availability tests
            // - Uptime monitoring services
            // 
            // Can be extended with custom health checks:
            // services.AddHealthChecks()
            //     .AddDbContextCheck<ApplicationDbContext>() // Database health
            //     .AddUrlGroup(new Uri("https://api.example.com"), "External API"); // External dependency health
            services.AddHealthChecks();
            
            // Return configured services
            return services;
        }
    }
}